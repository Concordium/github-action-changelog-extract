{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxBA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://javascript-action/./lib.js","../webpack://javascript-action/external node-commonjs \"fs\"","../webpack://javascript-action/external node-commonjs \"os\"","../webpack://javascript-action/webpack/bootstrap","../webpack://javascript-action/webpack/runtime/compat","../webpack://javascript-action/./index.js"],"sourcesContent":["const sectionHeaderPattern = /^## \\[(.*)]/;\n\nfunction extractSection(version, lines) {\n    // Find line index of the section of interest.\n    const sectionLineIdx = lines.findIndex((line) => {\n        const v = sectionHeaderPattern.exec(line);\n        return v && version.startsWith(v[1]);\n    });\n\n    // If a matching section was found, extract to end of file look for the line index of the next section in this slice.\n    // Otherwise, leave the list of extracted lines empty.\n    let extractedLines = [];\n    if (sectionLineIdx >= 0) {\n        extractedLines = lines.slice(sectionLineIdx);\n        const nextSectionLineIdx = extractedLines.findIndex((line, idx) => idx > 0 && sectionHeaderPattern.test(line));\n        // If a subsequent section was found, extract the lines up to and excluding the next section.\n        if (nextSectionLineIdx >= 0) {\n            extractedLines = extractedLines.slice(0, nextSectionLineIdx);\n        }\n    }\n    return extractedLines;\n}\n\n\nmodule.exports = {extractSection};\n","module.exports = require(\"fs\");","module.exports = require(\"os\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// Import std lib modules.\nconst { EOL } = require('os');\nconst { readFileSync, writeFileSync } = require('fs');\nconst { extractSection } = require('./lib');\n\n// Read inputs and file to which we write outputs.\nconst file = process.env.INPUT_FILE;\nconst version = process.env.INPUT_VERSION;\nconst outputFile = process.env.GITHUB_OUTPUT;\n\n// Read changelog file synchronously into a list of lines.\nconst lines = readFileSync(file, 'utf8').split(/\\r?\\n/);\n\nlet extractedLines = extractSection(version, lines);\n\n// Join extracted lines and trim surrounding whitespace. Trailing newline will be (re)added in 'toOutput'.\nconst res = extractedLines.join(EOL).trim();\n\n// Write result as an output.\nfunction toOutput(key, delimiter, value) {\n    return `${key}<<${delimiter}${EOL}${value}${EOL}${delimiter}${EOL}`;\n}\ntry {\n    writeFileSync(outputFile, toOutput('changelog', 'EOT', res), { encoding: 'utf8' });\n} catch (e) {\n    // TODO Report error properly.\n    console.error(`error: cannot write output file ${outputFile}:`, e);\n}\n"],"names":[],"sourceRoot":""}